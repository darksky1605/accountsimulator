//29.3.19

enum class ConstructionTimeType {Normal, Special};
enum class BuildingLocation {Planet, Moon, PlanetMoon};

template<ConstructionTimeType type, BuildingLocation location>
struct Building{
    static constexpr ConstructionTimeType constructionTimeType = type;
    static constexpr BuildingLocation buildingLocation = location;
    
    std::int64_t metBaseCosts;
    std::int64_t crysBaseCosts;
    std::int64_t deutBaseCosts;
    std::int64_t energyRequirement;
    
    float costIncreaseFactor;
    
    Building() : Building(0,0,0,0,1.0f){}
    
    Building(std::int64_t baseMet, std::int64_t baseCrys, std::int64_t baseDeut, std::int64_t energyReq, float costFactor)
        : metBaseCosts(baseMet), crysBaseCosts(baseCrys), crysDeutCosts(baseDeut), energyRequirement(energyReq), costIncreaseFactor(costFactor){}
    
    Resources getBuildCosts(int level) const{
        Resources result;
		
		if(level <= 0) return result;

        result.met = (std::int64_t)(metBaseCosts * std::pow(costIncreaseFactor, level-1));
        result.crystal = (std::int64_t)(crysBaseCosts * std::pow(costIncreaseFactor, level-1));
        result.deut = (std::int64_t)(deutBaseCosts * std::pow(costIncreaseFactor, level-1));
		
		if(result.met < 0) result.met = std::numeric_limits<std::int64_t>::max();
		if(result.crystal < 0) result.crystal = std::numeric_limits<std::int64_t>::max();
		if(result.deut < 0) result.deut = std::numeric_limits<std::int64_t>::max();
		
		return result;
    }

    Resources getTotalCosts(int level) const{
		
		Resources result;
		
		if(level <= 0) return result;
		
		result.met = (std::int64_t)(metBaseCosts * (1 - std::pow(costIncreaseFactor, level)) / (-(costIncreaseFactor - 1)));
		result.crystal = (std::int64_t)(crysBaseCosts * (1 - std::pow(costIncreaseFactor, level)) / (-(costIncreaseFactor - 1)));
		result.deut = (std::int64_t)(deutBaseCosts * (1 - std::pow(costIncreaseFactor, level)) / (-(costIncreaseFactor - 1)));
		
		if(result.met < 0) result.met = std::numeric_limits<std::int64_t>::max();
		if(result.crystal < 0) result.crystal = std::numeric_limits<std::int64_t>::max();
		if(result.deut < 0) result.deut = std::numeric_limits<std::int64_t>::max();
			
		return result;
	}

    float getConstructionTimeInDays(int level, int roboLevel, int naniLevel, int speedfactor) const{
        const float factor = constructionTimeType == ConstructionTimeType::Special ? 1.0f : std::max(4.f - level / 2.f, 1.0f);
        float seconds =  (costs.met + costs.crystal) * 1.44f / factor / (1 + roboLevel) / std::pow(2, naniLevel) / speedfactor;
        seconds = std::max(1.0f, seconds);
        float days = std::floor(seconds) / 60.f / 60.f / 24.f;
        return days;
    }
}


struct Metalmine : public Building<ConstructionTimeType::Normal, BuildingLocation::Planet>{

    Metalmine() : Building(60,15,0,0,1.5){}
    
    std::int64_t getEnergyConsumption(int level, int percent) const{
        constexpr float energyFactor = 10;
    
        const float factor = float(percent)/100.0f;
        return std::ceil(energyFactor * level * std::pow(1.1, level) * factor);
    }
    
    double getSimpleProduction(int level, int percent) const{
        const double factor = double(percent) / 100.0;
        return 30.0 * level * std::pow(1.1, level) * percent;
    }
    
};

struct Crystalmine : public Building<ConstructionTimeType::Normal, BuildingLocation::Planet>{

    Crystalmine() : Building(48,24,0,0,1.6){}

    std::int64_t getEnergyConsumption(int level, int percent) const{
        constexpr float energyFactor = 10;
    
        const float factor = float(percent)/100.0f;
        return std::ceil(energyFactor * level * std::pow(1.1f, level) * factor);
    }
    
    double getSimpleProduction(int level, int percent) const{
        const double factor = double(percent) / 100.0;
        return 20.0 * level * std::pow(1.1f, level) * percent;
    }
    
};

struct Deutsynth : public Building<ConstructionTimeType::Normal, BuildingLocation::Planet>{ 

    Deutsynth() : Building(225,75,0,0,1.5){}

    std::int64_t getEnergyConsumption(int level, int percent) const{
        constexpr float energyFactor = 20;
        
        const float factor = float(percent)/100.0f;
        return std::ceil(energyFactor * level * std::pow(1.1f, level) * factor);
    }
    
    double getSimpleProduction(int level, int percent, int temperature) const{
        const double factor = double(percent) / 100.0;
        return 10.0 * level * std::pow(1.1f, level) * (1.44f - 0.004f * temperature) * percent;
    }
    
};


struct Solarplant : public Building<ConstructionTimeType::Normal, BuildingLocation::Planet>{

    Solarplant() : Building(75,30,0,0,1.5f){}

    std::int64_t getSimpleEnergyProduction(int level) const{
		std::int64_t energy = 20 * level * std::pow(1.1f, level);
		return energy;
	}
	
};

struct Fusionplant : public Building<ConstructionTimeType::Normal, BuildingLocation::Planet>{

    FKW() : Building(900,360,180,0,1.8f){}

    std::int64_t getSimpleEnergyProduction(int level, int etechLevel) const{
        std::int64_t energy = (std::int64_t)(30 * level * std::pow((1.05f + etechLevel * 0.01f), level));
        return energy;
    }
    
};

struct Robo : public Building<ConstructionTimeType::Normal, BuildingLocation::PlanetMoon>{
    Robo() : Building(400,120,200,0,2.0f) {}
};

struct Nanite : public Building<ConstructionTimeType::Special, BuildingLocation::Planet>{
    Nanite() : Building(1000000,5000000,100000,0,2.0f) {}
};

struct Shipyard : public Building<ConstructionTimeType::Normal, BuildingLocation::PlanetMoon>{
    Shipyard() : Building(400,200,100,0,2.0f) {}
};

struct Metalstorage : public Building<ConstructionTimeType::Normal, BuildingLocation::PlanetMoon>{
    Metalstorage() : Building(1000,0,0,0,2.0f) {}
};

struct Crystalstorage : public Building<ConstructionTimeType::Normal, BuildingLocation::PlanetMoon>{
    Crystalstorage() : Building(1000,500,0,0,2.0f) {}
};

struct Deutstorage : public Building<ConstructionTimeType::Normal, BuildingLocation::PlanetMoon>{
    Deutstorage() : Building(1000,1000,0,0,2.0f) {}
};

struct Lab : public Building<ConstructionTimeType::Normal, BuildingLocation::Planet>{
    Lab() : Building(200,400,200,0,2.0f) {}
};

struct Terra : public Building<ConstructionTimeType::Normal, BuildingLocation::Planet>{
    Terra() : Building(0,50000,100000,1000,2.0f) {}
};

struct Alliancedepot : public Building<ConstructionTimeType::Normal, BuildingLocation::Planet>{
    Alliancedepot() : Building(20000,40000,0,0,2.0f) {}
};

struct Spacedock : public Building<ConstructionTimeType::Normal, BuildingLocation::Planet>{
    Spacedock() : Building(200,0,50,50,5.0f) {}
};

struct Lunarbase : public Building<ConstructionTimeType::Special, BuildingLocation::Moon>{
    Lunarbase() : Building(20000,40000,20000,0,2.0f) {}
};

struct Phalanx : public Building<ConstructionTimeType::Special, BuildingLocation::Moon>{
    Phalanx() : Building(20000,40000,20000,0,2.0f) {}
};

struct Jumpgate : public Building<ConstructionTimeType::Special, BuildingLocation::Moon>{
    Jumpgate() : Building(2000000,4000000,2000000,0,2.0f) {}
};

struct Silo : public Building<ConstructionTimeType::Normal, BuildingLocation::Planet>{
    Silo() : Building(20000,20000,1000,0,2.0f) {}
};



struct Research{
    std::int64_t metBaseCosts;
    std::int64_t crysBaseCosts;
    std::int64_t deutBaseCosts;
    std::int64_t energyRequirement;
    
    float costFactor;
    
    static Resources getBuildCosts(int level){
        Resources result;
		
		if(level <= 0) return result;

        result.met = (std::int64_t)(metBaseCosts * std::pow(costFactor, level-1));
        result.crystal = (std::int64_t)(crysBaseCosts * std::pow(costFactor, level-1));
        result.deut = (std::int64_t)(deutBaseCosts * std::pow(costFactor, level-1));
		
		if(result.met < 0) result.met = std::numeric_limits<std::int64_t>::max();
		if(result.crystal < 0) result.crystal = std::numeric_limits<std::int64_t>::max();
		if(result.deut < 0) result.deut = std::numeric_limits<std::int64_t>::max();
		
		return result;
    }

    static Resources getTotalCosts(int level){
		
		Resources result;
		
		if(level <= 0) return result;
		
		result.met = (std::int64_t)(info.metBaseCosts * (1 - std::pow(info.costFactor, level)) / (-(info.costFactor - 1)));
		result.crystal = (std::int64_t)(info.crysBaseCosts * (1 - std::pow(info.costFactor, level)) / (-(info.costFactor - 1)));
		result.deut = (std::int64_t)(info.deutBaseCosts * (1 - std::pow(info.costFactor, level)) / (-(info.costFactor - 1)));
		
		if(result.met < 0) result.met = std::numeric_limits<std::int64_t>::max();
		if(result.crystal < 0) result.crystal = std::numeric_limits<std::int64_t>::max();
		if(result.deut < 0) result.deut = std::numeric_limits<std::int64_t>::max();
			
		return result;
	}

    float getConstructionTimeInDays(int level, int labLevel, int speedfactor) const;
}




struct Unit{
    std::int64_t metBaseCosts;
    std::int64_t crysBaseCosts;
    std::int64_t deutBaseCosts;
    
    static Resources getBuildCosts(int count){
        Resources result;
		
		if(count <= 0) return result;

        result.met = metBaseCosts * count;
        result.crystal = crysBaseCosts * count;
        result.deut = deutBaseCosts * count;
		
		if(result.met < 0) result.met = std::numeric_limits<std::int64_t>::max();
		if(result.crystal < 0) result.crystal = std::numeric_limits<std::int64_t>::max();
		if(result.deut < 0) result.deut = std::numeric_limits<std::int64_t>::max();
		
		return result;
    }

    float getConstructionTimeInDays(int count, int naniLevel, int shipyardLevel, int speedfactor) const{
        float days = 0;
		
		if(level <= 0) return days;
		
		const Resources costs = getBuildCosts(count);
		
        if(shipyardLevel == 0){
            days = std::numeric_limits<float>::max();
        }else{
            const float hours = (costs.met + costs.crystal) / (2500.f * (1 + shipyardLevel) * std::pow(2, naniLevel)) / speedfactor;
            days = hours / 24.f;
        }
        
        return days;
    }
};




































------------------------------------------------------------

???

nani
fkw
met

permutationgroup(upgradegroup(upgradetask(nani, all)))
permutationgroup(upgradegroup(upgradetask(fkw, all)))
permutationgroup(upgradegroup(upgradetask(met, all)))


nani
fkw met

permutationgroup(upgradegroup(upgradetask(nani, all)))
permutationgroup(upgradegroup[nottransposed](upgradetask(fkw, all), upgradetask(met, all)))


nani
(fkw met)

permutationgroup(upgradegroup(upgradetask(nani, all)))
permutationgroup(upgradegroup[transposed](upgradetask(fkw, all), upgradetask(met, all)))


1 2 3 nani
4 5 6 fkw 4 5 6 met

permutationgroup(upgradegroup(upgradetask(nani, [1,2,3])))
permutationgroup(upgradegroup[nottransposed](upgradetask(fkw, [4,5,6]), upgradetask(met, [4,5,6])))

1 2 3 nani
(4 5 6 fkw 4 5 6 met) etech

permutationgroup(upgradegroup(upgradetask(nani, [1,2,3])))
permutationgroup(upgradegroup[transposed](upgradetask(fkw, [4,5,6]), upgradetask(met, [4,5,6])), upgradegroup[nottransposed](upgradetask(etech, researchplanet)))




struct UpgradeTask{
	ogh::EntityInfo entityInfo{};
	std::vector<int> locations{};

	UpgradeTask(){}
	UpgradeTask(const ogh::EntityInfo e, const std::vector<int>& l) : entityInfo(e), locations(l){}

	bool isResearch() const{
		return entityInfo.type == EntityType::Research;
	}

	std::vector<int> getLocations() const{
		return locations;
	}
};

struct UpgradeGroup{
	bool transposed;
	std::vector<UpgradeTask> tasks;
	
	bool isTransposed() const{
		return transposed;
	}
	
	std::vector<UpgradeTask> getTasks() const{
		if(transposed){
			auto first = tasks.begin();
			auto last = first;
			while(last != tasks.end()){
				assert(first->getLocations() == last->getLocations());
				++last;
			}
		}
		return tasks;
	}
};

struct PermutationGroup{
	std::vector<UpgradeGroup> groups;
};

template<class Container1, class Container2>
bool container_less_than_elementwise(const Container1& l, const Container2& r){
	auto pair = std::mismatch(l.begin(), l.end(), r.begin());
	if(pair.first == l.end() && pair.second == r.end()) 
		return false;
	if(pair.first == l.end())
		return true;
	if(pair.second == r.end())
		return false;
	return *(pair.first) < *(pair.second);
}

bool operator<(const UpgradeTask& l, const UpgradeTask& r){
	if(l.entityInfo.name != r.entityInfo.name)
		return l.entityInfo.name < r.entityInfo.name;
	
	return container_less_than_elementwise(l.getLocations(), r.getLocations());
}

bool operator<(const UpgradeGroup& l, const UpgradeGroup& r){
	if(!l.transposed && r.transposed)
		return true;
	if(l.transposed && !r.transposed)
		return false;
		
	return container_less_than_elementwise(l.tasks, r.tasks);
}

bool operator<(const PermutationGroup& l, const PermutationGroup& r){
	return container_less_than_elementwise(l.groups, r.groups);
}
